An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.

Given an integer `n`, return *the* `nth` ***ugly number***.

 

**Example 1:**

```
Input: n = 10
Output: 12
Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.
```

**Example 2:**

```
Input: n = 1
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
```

 

**Constraints:**

- `1 <= n <= 1690`



> **思路**

三指针法：因为丑数只是因数只有2,3,5的数;

所以先设置一个dp数组表示当前已经找出并排列好的丑数数组；

再3个指针：i,j,k 表示 将当前已经排好的数组元素 *2，*3，*5 所得的数组（实际上，因为所得的数字最终会加入唯一的排序数组，所以并不用真正将3个数组建立起来），

因为排序后数组*2，*3，*5得到的也是已经排序数组，接下来的目的就是从这3个虚拟数组中的头元素中取得最小那个值；（实际上并不会出现3个数组）

所以关键就是如何用这3个指针进行选择，

实际上排序并不是在加入排序数组后才整理排序，而是每次用老元素*2，*3，*5生成新元素的时候，选择最小的加入达到排序目的，这个时候指针移动就起到作用了，如下过程所示：

\-----------------------------------------------------

已经排好的数组，先放进第一个丑数1:[1]

排好数组2 ：[1]*2=2

排好数组3 ：[1]*3=3

排好数组5 ：[1]*5=5

选结果中最小的数加入数组，此时明显是2，新的排序数组为[1,2]；

\-----------------------------------------------------

已经排好的数组:[1，2]------此时上次结果中，2，3，5只用到了2；但3明显是这次需要加入的数；既然2已经加入，再去对比2没意义了，那么就将 （*2的指针） [1]转向下一位[2]，对比 （下一个元素*2 和3，5）的大小，取最小的加入；

排好数组2 ：[2]*2=4

排好数组3 ：[1]*3=3

排好数组5 ：[1]*5=5

选结果中最小的数加入数组，此时明显是2，新的排序数组为[1,2,3]；

\-----------------------------------------------------

已经排好的数组:[1，2，3]------3已经加入，移动它的指针到排序数组下一位；

排好数组2 ：[2]*2=4

排好数组3 ：[2]*3=6

排好数组5 ：[1]*5=5

选结果中最小的数加入数组，此时明显是4，新的排序数组为[1,2,3,4]；

依次类推；可以看到，实际上，只需将指针进行分别移动就可以了；所以要做出3个指针；

\-----------------------------------------------------

维护3个值val2，val3，val5，表示将当前排列好数组 分别*2，*3，*5所得的结果数；

因为可能3组数出现重复现象，所以要判断是否重复后再加入



> **解法**

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int a = 0, b = 0, c = 0;
        for (int i = 1; i < n; i++) {
            int n2 = 2 * dp[a], n3 = 3 * dp[b], n5 = 5 * dp[c];
            dp[i] = Math.min(n2, Math.min(n3, n5));
            if (dp[i] == n2) a++;
            if (dp[i] == n3) b++;
            if (dp[i] == n5) c++;
        }
        return dp[n-1];
    }
}
```

**时间复杂度：**$ O(N) $

**空间复杂度：**$ O(N) $