> ## 题目

**给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据 O(N) 的情况下，能够随机选取出m个不重复的数据。**

> ## 分析

这个场景强调了3件事：

1. 数据流长度N很大且不可知，所以不能一次性存入内存。
2. 时间复杂度为O(N)。
3. 随机选取m个数，每个数被选中的概率为m/N。

第1点限制了不能直接取N内的m个随机数，然后按索引取出数据。

第2点限制了不能先遍历一遍，然后分块存储数据，再随机选取。

第3点是数据选取绝对随机的保证。


> ## 代码

算法思路大致如下：

1. 如果接收的数据量小于m，则依次放入蓄水池。
2. 当接收到第i个数据时，i >= m，在[0, i]范围内取以随机数d，若d的落在[0, m-1]范围内，则用接收到的第i个数据替换蓄水池中的第d个数据。
3. 重复步骤2。

```java
Random random = new Random();
int[] reservoir = new int[m];

// init
for (int i = 0; i < reservoir.length; i++)
{
    reservoir[i] = dataStream[i];
}

for (int i = m; i < dataStream.length; i++)
{
    // 随机获得一个[0, i]内的随机整数
    int d = random.nextInt(i + 1);
    // 如果随机整数落在[0, m-1]范围内，则替换蓄水池中的元素
    if (d < m) {
        reservoir[d] = dataStream[i];
    }
}
```

**注：** 这里使用已知长度的数组dataStream来表示未知长度的数据流，并假设数据流长度大于蓄水池容量m。



> ## 证明

下面用白话文推导验证该算法。假设数据开始编号为1.

**第 i 个接收到的数据最后能够留在蓄水池中的概率** = **第 i 个数据进入过蓄水池的概率** * **之后第 i 个数据不被替换的概率**（第i +1 到第N次处理数据都不会被替换）。

1. 当 i<=m 时，数据直接放进蓄水池，所以**第 i 个数据进入过蓄水池的概率 = 1**。
2. 当 i>m 时，在 `[1,i]` 内选取随机数 d，如果d <= m，则使用第 i 个数据替换蓄水池中第 d 个数据，因此**第i个数据进入过蓄水池的概率 = m/i** 。
3. 当 i<=m 时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为 `m/(m+1)`，会替换掉第i个数据的概率为 `1/m` ，则第 m+1 次处理替换掉第i个数据的概率为 $m/(m+1) \times 1/m = 1/(m+1)$，不被替换的概率为$ 1-1/(m+1) = m/(m+1) $。依次，第 m+2 次处理不替换掉第i个数据概率为 $(m+1)/(m+2)$ ...第N次处理不替换掉第i个数据的概率为 $(N-1)/N$。所以，之后**第i个数据不被替换的概率=m/(m+1)\*(m+1)/(m+2)\*...\*(N-1)/N=m/N**。
4. 当 i>m 时，程序从接收到第i+1个数据时开始有可能替换第 i 个数据。则参考上述第3点，**之后第i个数据不被替换的概率=i/N**。
5. 结合第1点和第3点可知，当 i<=m 时，第 i 个接收到的数据最后留在蓄水池中的概率=$ 1\times m/N=m/N $。结合第2点和第4点可知，当 i>m 时，第 i 个接收到的数据留在蓄水池中的概率=$ m/i \times i/N=m/N $。综上可知，**每个数据最后被选中留在蓄水池中的概率为m/N**。

