主要用于解决一些**元素分组**的问题。它管理一系列**不相交的集合**，并支持两种操作：

- **合并**（Union）：把两个不相交的集合合并为一个集合。
- **查询**（Find）：查询两个元素是否在同一个集合中。

 初始化

```java
#define MAXN 100
int Parent[MAXN];

void init(int n) {
    for (int i = 0; i < n; i++) {
        Parent[i] = i;        //存放每个结点的结点（或双亲结点）
    }
}
```

查询

```java
//查询根结点
int find(int x){
    if(Parent[x] == x)
        return x;
    else
        return find(Parent[x]);
}
```

合并

```java
//合并,把 j 合并到 i 中去，就是把j的双亲结点设为i
void merge(int i,int j){
    Parent[find(j)] = find(i);
}
```



以上就是基础模版，比较简单易懂，还有两个优化的方式

- 路径压缩

  我们在上面的merge过程中很容易出现一个细长的链条，就像二叉树中的一些极端情况，这是不利于查询的。所以我们的想法就是直接让孩子链接到最上面的祖先

  其实也比较好实现，只需要在find时候，让路径上的每个节点都连接到祖先即可

  ```java
  int find(int x)
  {
      if(x == fa[x])
          return x;
      else{
          fa[x] = find(fa[x]);  //父节点设为根节点
          return fa[x];         //返回父节点
      }
  }
  
  ===以下为简化写法，注意加括号===
  int find(int x)
  {
      return x == fa[x] ? x : (fa[x] = find(fa[x]));
  }
  ```

  

- 按秩合并

  有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个**菊花图**（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。例如，现在我们有一棵较复杂的树需要与一个单元素的集合合并：

  ![](https://typora-us.oss-us-west-1.aliyuncs.com/20221130170923.png)

  假如这时我们要merge(7,8)，如果我们可以选择的话，是把7的父节点设为8好，还是把8的父节点设为7好呢？

  当然是后者。因为如果把7的父节点设为8，会使树的**深度**（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。

  这启发我们：我们应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。

  我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的**子树**的深度）。一开始，把所有元素的rank（**秩**）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。

  路径压缩和按秩合并如果一起使用，时间复杂度接近 O(n) ，但是很可能会破坏rank的准确性



初始化

```java
===初始化===
void init(int n) {
    for (int i = 1; i <= n; ++i)
    {
        fa[i] = i;
        rank[i] = 1;
    }
}


===合并===
void merge(int i, int j) {
    int x = find(i), y = find(j);    //先找到两个根节点
    if (rank[x] <= rank[y])
        fa[x] = y;
    else
        fa[y] = x;
    if (rank[x] == rank[y] && x != y)
        rank[y]++;                   //如果深度相同且根节点不同，则新的根节点的深度+1
}
```

