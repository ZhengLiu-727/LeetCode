Given a **non-empty** array `nums` containing **only positive integers**, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

**Example 1:**

```java
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
```

**Example 2:**

```java
Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
```

**Constraints:**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

> **思路**

先计算`sum`，如果`sum`为奇数，那么一定不可能平分

然后建立数组 `boolean[][] dp` ，`dp[n][m]`代表在index为n时，是否可以累计和为m

> **解法**

```java
class Solution {
  public boolean canPartition(int[] nums) {
    int sum = 0;
    for (int num : nums) {
      sum += num;
    }
    if (sum % 2 != 0) {
      return false;
    }
    
    int target = sum / 2;
    int n = nums.length;

    boolean[][] dp = new boolean[n+1][target+1];
    dp[0][0] = true;
    for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= target; j++) {
        // 如果当前值比目标值（也就是j）都大，那不可能是加上当前值导致的
        if (j >= nums[i-1]) dp[i][j] =  dp[i-1][j] || dp[i-1][j-nums[i-1]];
        else dp[i][j] = dp[i-1][j];
      }
    }
    return dp[n][target];
  }
}
```

时间复杂度：O(N * t)，N为数组长度，t为数组之和

空间复杂度：O(N * t)，N为数组长度，t为数组之和